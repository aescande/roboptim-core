<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Quick start</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00010.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Quick start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Solving a problem is done through several steps:</p>
<ul>
<li>Define your cost function by deriving one kind of function, depending on whether or not you want to provide a jacobian and/or a hessian.</li>
<li>Define your constraints functions in the same manner.</li>
<li>Build an instance of problem matching your requirements.</li>
<li>Use one of the solvers to solve your problem.</li>
</ul>
<p>The following example defines a cost function F and two constraints G0 and G1.</p>
<h2><a class="anchor" id="problem"></a>
Problem definition</h2>
<p>The problem that will be solved is:</p>
<p><img class="formulaInl" alt="$min_{x \in \mathbb{R}^4} x_1 x_4 (x_1 + x_2 + x_3) + x_3$" src="form_39.png"/></p>
<p>with the following constraints:</p>
<ul>
<li><img class="formulaInl" alt="$x_1 x_2 x_3 x_4 \geq 25$" src="form_40.png"/></li>
<li><img class="formulaInl" alt="$x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40$" src="form_41.png"/></li>
<li><img class="formulaInl" alt="$1 \leq x_1, x_2, x_3, x_4 \leq 5$" src="form_42.png"/></li>
</ul>
<h2><a class="anchor" id="cost"></a>
Defining the cost function.</h2>
<p>The library contains the following hierarchy of functions:</p>
<ul>
<li>optimization::Function</li>
<li>optimization::DerivableFunction</li>
<li>optimization::TwiceDerivableFunction</li>
<li>optimization::QuadraticFunction</li>
<li>optimization::LinearFunction</li>
</ul>
<p>When defining a new function, you have to derive your new function from one of those classes. Depending on the class you derive from, you will be have to implement one or several methods:</p>
<ul>
<li>impl_compute that returns the function's result has to be defined for all functions.</li>
<li>impl_gradient which returns the function's gradient is to be defined for DerivableFunction and its subclasses.</li>
<li>impl_hessian for TwiceDerivableFunction functions and its subclasses.</li>
</ul>
<p>It is usually recommended to derive from the deepest possible class of the hierarchy (deriving from TwiceDerivableFunction is better than DerivableFunction).</p>
<p>Keep in mind that the type of the function represents the amount of information the solver will get, not the real nature of a function (it is possible to avoid defining a hessian by deriving from DerivableFunction, even if you function can be derived twice).</p>
<p>In the following sample, a TwiceDerivableFunction will be defined.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>F : <span class="keyword">public</span> <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a>
{
  F () : <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a> (4, 1)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    vector_t res (m);
    res (0) = x[0] * x[3] * (x[0] + x[1] + x[2]) + x[3];
    <span class="keywordflow">return</span> res;
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()
  {
    gradient_t grad (n);

    grad[0] = x[0] * x[3] + x[3] * (x[0] + x[1] + x[2]);
    grad[1] = x[0] * x[3];
    grad[2] = x[0] * x[3] + 1;
    grad[3] = x[0] * (x[0] + x[1] + x[2]);
    <span class="keywordflow">return</span> grad;
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()

  {
    matrix_t h (n, n);
    h (0, 0) = 2 * x[3];
    h (0, 1) = x[3];
    h (0, 2) = x[3];
    h (0, 3) = 2 * x[0] + x[1] + x[2];

    h (1, 0) = x[3];
    h (1, 1) = 0.;
    h (1, 2) = 0.;
    h (1, 3) = x[0];

    h (2, 0) = x[3];
    h (2, 1) = 0.;
    h (2, 2) = 0.;
    h (2, 3) = x[1];

    h (3, 0) = 2 * x[0] + x[1] + x[2];
    h (3, 1) = x[0];
    h (3, 2) = x[0];
    h (3, 3) = 0.;
    <span class="keywordflow">return</span> h;
  }
};
</pre></div><h2><a class="anchor" id="constraints"></a>
Defining the constraints.</h2>
<p>A constraints is no different from a cost function and can be defined in the same way than a cost function.</p>
<p>The following sample defines two constraints which are twice derivable functions.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>G0 : <span class="keyword">public</span> <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a>
{
  G0 ()
    : <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a> (4, 1)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    vector_t res (m);
    res (0) = x[0] * x[1] * x[2] * x[3];
    <span class="keywordflow">return</span> res;
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()
  {
    gradient_t grad (n);

    grad[0] = x[1] * x[2] * x[3];
    grad[1] = x[0] * x[2] * x[3];
    grad[2] = x[0] * x[1] * x[3];
    grad[3] = x[0] * x[1] * x[2];
    <span class="keywordflow">return</span> grad;
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()
  {
    matrix_t h (n, n);
    h (0, 0) = 0.;
    h (0, 1) = x[2] * x[3];
    h (0, 2) = x[1] * x[3];
    h (0, 3) = x[1] * x[2];

    h (1, 0) = x[2] * x[3];
    h (1, 1) = 0.;
    h (1, 2) = x[0] * x[3];
    h (1, 3) = x[0] * x[2];

    h (2, 0) = x[1] * x[3];
    h (2, 1) = x[0] * x[3];
    h (2, 2) = 0.;
    h (2, 3) = x[0] * x[1];

    h (3, 0) = x[1] * x[2];
    h (3, 1) = x[0] * x[2];
    h (3, 2) = x[0] * x[1];
    h (3, 3) = 0.;
    <span class="keywordflow">return</span> h;
  }
};

<span class="keyword">struct </span>G1 : <span class="keyword">public</span> <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a>
{
  G1 ()
    : <a class="code" href="a00136.html#a8fe946bb68641ff262c0cfef38af94d5" title="Legacy name of DifferentiableFunction.">TwiceDerivableFunction</a> (4, 1)
  {
  }

  <span class="keywordtype">void</span>
  impl_compute (result_t&amp; result, <span class="keyword">const</span> argument_t&amp; x) <span class="keyword">const</span> <span class="keywordflow">throw</span> ()
  {
    vector_t res (m);
    res (0) = x[0]*x[0] + x[1]*x[1] + x[2]*x[2] + x[3]*x[3];
    <span class="keywordflow">return</span> res;
  }

  <span class="keywordtype">void</span>
  impl_gradient (gradient_t&amp; grad, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()
  {
    gradient_t grad (n);

    grad[0] = 2 * x[0];
    grad[1] = 2 * x[1];
    grad[2] = 2 * x[2];
    grad[3] = 2 * x[3];
    <span class="keywordflow">return</span> grad;
  }

  <span class="keywordtype">void</span>
  impl_hessian (hessian_t&amp; h, <span class="keyword">const</span> argument_t&amp; x, <span class="keywordtype">int</span>) <span class="keyword">const</span> throw ()
  {
    matrix_t h (n, n);
    h (0, 0) = 2.;
    h (0, 1) = 0.;
    h (0, 2) = 0.;
    h (0, 3) = 0.;

    h (1, 0) = 0.;
    h (1, 1) = 2.;
    h (1, 2) = 0.;
    h (1, 3) = 0.;

    h (2, 0) = 0.;
    h (2, 1) = 0.;
    h (2, 2) = 2.;
    h (2, 3) = 0.;

    h (3, 0) = 0.;
    h (3, 1) = 0.;
    h (3, 2) = 0.;
    h (3, 3) = 2.;
    <span class="keywordflow">return</span> h;
  }
};
</pre></div><h2><a class="anchor" id="problem"></a>
Problem definition</h2>
<p>The last part of this tutorial covers how to build a problem and solve it. The steps are:</p>
<ul>
<li>Instanciate your functions (cost functions and constraints).</li>
<li>Pass them to the problem.</li>
<li>Optional: set a starting point.</li>
<li>Instanciate a solver which solves your class of problem.</li>
<li>Solve the problem by calling minimum.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> run_test ()
{
  F f;
  G0 g0;
  G1 g1;

  CFSQPSolver::problem_t pb (f);

  <span class="comment">// Set bound for all variables.</span>
  <span class="comment">// 1. &lt; x_i &lt; 5. (x_i in [1.;5.])</span>
  <span class="keywordflow">for</span> (Function::size_type i = 0; i &lt; pb.function ().n; ++i)
    pb.argBounds ()[i] = T::makeBound (1., 5.);

  <span class="comment">// Add constraints.</span>
  pb.addConstraint (&amp;g0, T::makeUpperBound (25.));
  pb.addConstraint (&amp;g1, T::makeBound (40., 40.));

  <span class="comment">// Set the starting point.</span>
  Function::vector_t start (pb.function ().n);
  start[0] = 1., start[1] = 5., start[2] = 5., start[3] = 1.;

  initialize_problem (pb, g0, g1);

  <span class="comment">// Initialize solver</span>
  CFSQPSolver solver (pb);

  <span class="comment">// Compute the minimum and retrieve the result.</span>
  CFSQPSolver::result_t res = solver.minimum ();

  <span class="comment">// Display solver information.</span>
  std::cout &lt;&lt; solver &lt;&lt; std::endl;

  <span class="comment">// Check if the minimization has succeed.</span>
  <span class="keywordflow">switch</span> (solver.minimumType ())
    {
    <span class="keywordflow">case</span> SOLVER_NO_SOLUTION:
      std::cerr &lt;&lt; <span class="stringliteral">&quot;No solution.&quot;</span> &lt;&lt; std::endl;
      <span class="keywordflow">return</span> 1;
    <span class="keywordflow">case</span> SOLVER_ERROR:
      std::cerr &lt;&lt; <span class="stringliteral">&quot;An error happened: &quot;</span>
    &lt;&lt; solver.getMinimum&lt;SolverError&gt; ().what () &lt;&lt; std::endl;
      <span class="keywordflow">return</span> 2;

    <span class="keywordflow">case</span> SOLVER_VALUE_WARNINGS:
      {
  <span class="comment">// Get the ``real&#39;&#39; result.</span>
  Result&amp; result = solver.getMinimum&lt;ResultWithWarnings&gt; ();
  <span class="comment">// Display the result.</span>
  std::cout &lt;&lt; <span class="stringliteral">&quot;A solution has been found (minor problems occurred): &quot;</span>
      &lt;&lt; std::endl
      &lt;&lt; result &lt;&lt; std::endl;
  <span class="keywordflow">return</span> 0;
      }
    <span class="keywordflow">case</span> SOLVER_VALUE:
      {
  <span class="comment">// Get the ``real&#39;&#39; result.</span>
  Result&amp; result = solver.getMinimum&lt;Result&gt; ();
  <span class="comment">// Display the result.</span>
  std::cout &lt;&lt; <span class="stringliteral">&quot;A solution has been found: &quot;</span> &lt;&lt; std::endl;
  std::cout &lt;&lt; result &lt;&lt; std::endl;
  <span class="keywordflow">return</span> 0;
      }
    }

  <span class="comment">// Should never happen.</span>
  assert (0);
  <span class="keywordflow">return</span> 42;
}
</pre></div><p>This is the last piece of code needed to instantiate and resolve an optimization problem with this package.</p>
<p>To see more usage examples, consider looking at the test directory of the project which contains the project's test suite. </p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">User manual</a>      </li>
</body>
</html>
